---
- name: "Create 3scale namespace: {{ threescale_namespace }}"
  include_role:
    name: namespace
    tasks_from: create
  vars:
    name: "{{ threescale_namespace }}"
    display_name: "{{ threescale_display_name }}"
    monitor: true
    is_service: true

# Used to pull images from registry.redhat.io
- include_role:
    name: imagestream_pull_secret
  vars:
    namespace: "{{ threescale_namespace }}"
    product_ns_pull_secret_name: "{{ threescale_pull_secret_name }}"

- name: Link imagestream pull secret for images
  shell: oc secrets link default {{ threescale_pull_secret_name }} --for=pull -n {{ threescale_namespace }}

- name: Check namespace for existing resources
  shell: oc get all -n {{ threescale_namespace }}
  register: threescale_resources_exist

- name: Check for errored deploy pods
  shell: oc get pods --namespace {{ threescale_namespace }}  |  grep  "deploy" | grep "Failed" | cut -d " " -f 1
  register: errored_deploy_pods

- name: Delete errored deploy pods
  shell: oc delete pod --namespace {{ threescale_namespace }} {{ errored_deploy_pods.stdout }}
  when: errored_deploy_pods.stdout != ""

# setup for enabling wildcard route
- name: Allow router to accept wildcard routes
  shell: oc set env dc/router ROUTER_ALLOW_WILDCARD_ROUTES=true -n default
  when: enable_wildcard_route

- set_fact:
    wildcard_policy_param: "-p WILDCARD_POLICY=Subdomain"
  when: enable_wildcard_route

- name: "Provision 3scale in namespace: {{ threescale_namespace }}"
  block:
    - name: 'Install 3scale using filesystem template'
      shell: oc process -n {{ threescale_namespace }} -f {{ threescale_template }} -p WILDCARD_DOMAIN={{ threescale_route_suffix }} {{ wildcard_policy_param }}| oc create -n {{ threescale_namespace }} -f -
      when: threescale_file_upload_storage == "filesystem"

    - name: 'Install 3scale using s3 template'
      shell: >
        oc process -n {{ threescale_namespace }} -f {{ threescale_template_s3 }} -p WILDCARD_DOMAIN={{ threescale_route_suffix }} {{ wildcard_policy_param }} -p AWS_BUCKET={{ threescale_storage_s3_aws_bucket }} -p AWS_REGION={{ threescale_storage_s3_aws_region }} -p AWS_ACCESS_KEY_ID={{ threescale_storage_s3_aws_access_key }} -p AWS_SECRET_ACCESS_KEY={{ threescale_storage_s3_aws_secret_key }}  | oc create -n {{ threescale_namespace }} -f -
      when: threescale_file_upload_storage == "s3"
  when: threescale_resources_exist.stderr == "No resources found."

- import_tasks: resources.yml

- import_tasks: routes.yml
  when: not enable_wildcard_route

- name: "Setup pv-based storage"
  block:
    - name: "Check for storage class: {{ threescale_pvc_rwx_storageclassname }}"
      shell: oc get storageclass {{ threescale_pvc_rwx_storageclassname }}
      register: storageclass_exists
      failed_when: storageclass_exists.stderr != '' and 'NotFound' not in storageclass_exists.stderr

    # Temporary Workaround until 3Scale update their AMP template
    # to support storageclass names (https://issues.jboss.org/browse/THREESCALE-1323)
    - name: Remove original system-storage PVC
      shell: oc delete pvc system-storage -n {{ threescale_namespace }}
      when: threescale_resources_exist.stderr == "No resources found." and storageclass_exists.rc == 0

    - name: Generate system-storage pvc template
      template:
        src: "system-storage-pvc.yml.j2"
        dest: /tmp/system-storage-pvc.yml
      when: storageclass_exists.rc == 0

    - name: "Create system-storage PVC with storageClassName: {{ threescale_pvc_rwx_storageclassname }}"
      shell: oc create -f /tmp/system-storage-pvc.yml -n {{ threescale_namespace }}
      when: threescale_resources_exist.stderr == "No resources found." and storageclass_exists.rc == 0
  when: threescale_file_upload_storage == "filesystem"

- import_tasks: check_readiness.yml
- import_tasks: access_token.yml
- import_tasks: users.yml
- import_tasks: sso.yml
- import_tasks: service_discovery.yml
